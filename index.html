<!DOCTYPE html>
<html>
<body>
<h1>Tony's CS 260 blog!</h1>

<h2>Homework 6 Response</h2>
<p>

- Projects have gone wrong due to lack of calendar time. The cause for this are due to.
1. Our techniques of Estimating are poorly developed.
2. These techniques think effort is the same as progress; men and months are interchangeable. Ex: it takes 1 person 6 months to write a program so it should take 6 people 1 month to make the same program; this tends to normally be false.
3. Since we are uncertain of the estimates, our managers lack the courteous stubbornness other managers can show such as it takes time to develop a quality product.
4. Schedule progress is poorly monitored.
5. When the schedule starts to slip adding more manpower is usually the go to solution, but that normally doesn't fix the problem, usually it ends in disaster.
</p>
<p>
One interesting point the chapter makes is that all programmers are optimists. I have to agree with this point. I like to think that everything I do would work on the first try. Normally it does not but for some reason I start with this assumption on each project even when I know that won't happen. Its something I do need to work on with programming but it does make the project feel less monumental when you go in with a smile rather than a pessimistic approach. Really I feel I need to reign in my expectations a bit more rather than just assume everything I touch will break, and it will at one point or another.
</p>
<p>
I did find the explanation of the Man-month to make a lot of sense. Since most of programing starts a theoretical ideas on how to do something and then goes into the task of coding these ideas out, the idea that adding more man power to a product will make it go faster is incorrect. From hearing many professors and peers talk about programing work places, it sounds like many upper management people feel that software engineering or programing in general is similar to building a car, or manufacturing. The difference is for some of these programs you can't follow a set of instructions to build so you need to create them as you go, basically. I also liked the explanation of how adding more men actually lengthens the schedule, good stuff.
</p>
<p>
The rest of the chapter goes into testing estimates, how a manager should stand up for their estimates, and to make sure their team can work through a schedule disaster. All of these are great skills for a manager in any field, not just programing. I thoroughly liked the information brought up here and may even talk to one of my mentors in the management department at Smith about this book, its really interesting to see management techniques from a different field that's not just manufacturing.
</p>

<h2>12 Factor Response</h2>
<p>
I found this very interesting. I did not know this much thought went into building an app. This process though really does help line things out for how to build an app. I am sure though that you don’t need all of this for a single app, but can pick and choose depending on what you are trying to accomplish, for example not all apps need port binding.
</p>
<p>
Out of all of this, I thought the Codebase was the most interesting. It makes sense that to have a codebase you would want to use libraries when writing apps, as we are doing in class, but I felt that this chapter went into great detail explaining just why it needs this as well as how a codebase works through production, staging, and development.
</p>
<p>
The one section I am confused on is Concurrency. This section used a lot of terms I was not familiar with, or only had a passing familiarity with, and even after following their definitions from the website I still couldn’t comprehend this section.
</p>
<p>
Overall I did enjoy this reading. It does get very technical in areas but I am sure with more time I will come to understand these technical terms.
</p>
<h2>Pragmatic Programer Chapter 3 Insights</h2>
<h3>Post 4: 2/13/2017</h3>

<p>
The main idea with this section is that for a programer to be successful they need to use the right tools, just like
any professional. They also need to be set up for success, either by doing it themselves or having the support structure
in place to be successful. The main thing I noticed that I was at fault for for far to long was only using a test
editor instead of a good code editor. Also using Source Code Control is extremely helpful that I feel should be
emphasied more in coding practices. 
</p>

<p>
The other main thing I took away from this chapter is debugging. What spoke to me was to not panic. This is something
that I do to often. I freak out over code not working and get to concerned with it not working so I do not put in
as much time as necessary to make sure it is done correctly. I am getting over this fear and continuing to work on it each day.
</p>

<p>
I don't quite understand code generators from this section. They seem extremely helpful but how does the machine know
exactly what you need to generate? I would like to look into this a bit more to see how they work but right now it sounds
to good to be true. 
</p>

<h2>Pragmatic Programer Chapter 2 Insights</h2>
<h3>Post 3: 1/23/2017</h3>

<p>
The evils of duplication:
The main thing that I took from this section is that we should not be duplicating the code you create. If you
create one method don't recreate its functions in another method. </p>

<p>Orthogonality:
Here we learned that if a project/system is independent then it fufils the definition of Orthogonality. Mainly
this means that if one change in the system doesn't affect another then it is Orthogonality. </p>

<p>Reversibility:
Make sure that your code is reversable. This means that you should keep your code and entire project flexable. 
By entire project it means to keep your architecture, deployment, and vendor integration flexable. 
This is incase a hiccup comes along and requires you to change your project, either a light change or dramatic 
change to make the change less challenging. </p>

<p>Tracer Bullets and Prototypes:
This is basically a framework, or skeleton for your project. It contains everything that you need to further 
develop your porject. This allows multiple things such as having users see something early, devlopers build a 
structure to work in, the developers also have an integration platform, you can demonstrate your program a bit,
and you have a better feel for progress. The tracer bullet approach you keep throughout the project. With 
Prototyping though you would through most of that out once your done exploring that concept. To use a 
prototype, you can use dummy data where appropriate, it probably will only function for a small portion
of the project. The prototype may also not work at all and that is okay. Lastly prototype code also will 
be very bare bones since it's probably not being used in the final version of the project.</p>

<p>Domain Languages:
People can create mini languages in their projects to work closer with the domain. This allows the project 
workers to have better access to the structure of the languages. This doesn't mean that everyone should have 
access to these languages but it may help your team or yourself to work on the project more efficiently and 
effectivly.</p>

<p>Estimating:
Being able to estimate how long it will take your team to complete your project will help tell upper managment
how long you will need to make your project. Make sure your team understands what managment wants built, figure
out how to build it effectivly, estimate how your project works by calculating running times and other things.
The main thing with estimates is to make sure you communicate effectivly to those who need to know the estimated
time it will take to make the project.</p>


<h2>Pragmatic Programer Chapter 1 Insights</h2>
<h3>Post 2: 1/16/2017</h3>

<p> 
The main insights that I found important in chapter 1 are to look at the bigger picture,
take responsibility for your work, be a source of change, make sure your code is good enough, and invest
in your knowledge portfolio. Starting this off, I really like how the book goes into keeping in mind the bigger
picture of a project. You need to make sure that what you are delivering is what the organization, or team,
really needs and not to go program off on a tangent and turn the project into something it is not. Going off
of that each person needs to take responsibility of their part of the project. This doesn't mean for a person 
to go and be a hermit and work on their project by themselves, this means they need to go and work on it but
keep in mind it is a team effort and ask questions when they arrise. Also if something goes wrong, own it
try to fix it as best as you can and then go and talk with the manager/team/teacher. 
</p>

<p>
The next point that was brought up was to make sure your code is "good enough". I put that in quotation
to say that it doesn't mean that your code is to be sloppy and bad but that it meets your teams goals. This 
rounds back to the idea that you should focus on the bigger picture of the project and make sure it meets team
requirements. Lastly, the main point I took away from this is that you need to stay up to date on the field.
Continuing to invest in your education will help you succeed as a Software engineer, programmer, or whatever
field you decide to focus on. Overall this chapter was very incitful and I enjoyed reading it. 
</p>

<h2>What software engineering means to me.</h2>
<h3>Post 1: 1/16/2017</h3>

<p>
Software engineering is what makes everything work in today's world. It allows me cook food in a microwave,
play video games on my Playstation, and turn in homework. It lets everyone in this world stay connected because
with out software we wouldn't have applications like Skype to stay connected. Its one of those things that
everyone sees and uses in a day to day setting but you wouldn't really realize it unless you thought about it.
Overall its one of the most important disciplines that will continue to be important and become even more 
important as time goes on. 
</p>

<p>&nbsp</p>
<p> Last updated 3/22/17</p>
</body>
</html>
